# **Node.js基本原理的简单介绍**

## **本章提纲**

1. Node.js的原理
    1. V8
    2. Libuv
        1. 事件循环
        2. I/O请求
        3. 事件分配器
        4. 事件队列
2. Node.js的特点
    1. 多线程编程模式
    2. 事件驱动与多线程的区别
    3. 单线程与动态编译
    4. C++模块入门

----

## **第一节 Node.js的原理**

首先我们回答一个问题, Node.js是什么? 官网给出的回答是'JavaScript runtime built on Chrome's V8 JavaScript engine', 那么如何理解这个答案呢? 我认为Node.js最主要由两部分组成: 

    1. V8
    2. Libuv. 

那么接下来我们看看这两部分分别做了哪些事情.

----

### **V8做了什么**

V8在执行代码的过程我们可以简单理解为4个步骤: 

|组件|产物|
|:--|:--|
|-|Source Code|
|Tokenizer|Token|
|Parser|Abstract syntax tree|
|Ignition解释器|Byte Code|
|TurboFan|Native code && run|

V8首先会将js源码解析成抽象语法树，通过ignition遍历语法树生成相应的字节码。这些字节码在执行过程中会被TurboFan编译成本地代码(机器码). 

另外我们经常听到的加速执行的技术 **JIT** , 我们可以简单理解为在解释执行的过程中缓存热点的本地代码, 这里的关键是判断代码是否'热点'的算法.

17年之后V8抛弃了原先直接从AST到本地码的解释方式, 引入了字节码作为中间层, 主要考量是: 

    1.（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间
    2. 提高代码的启动速度
    3. 对 v8 的代码进行重构，降低 v8 的代码复杂度 (机器代码的多样性, 优化复杂)

这里我们只是对V8做一个简单的了解和梳理, 目的不是深入V8, 而只是知道他做了什么, 从而更方便地认识到另一部分(Libuv)做了什么.

----

### **Libuv做了什么**

接下来我们就来讨论Node.js的另一重要组成部分, Libuv的作用和简单的结构.

Libuv官网上的描述是'libuv是一个高性能/事件驱动I/O的跨平台API集'. 所以我们又可以将它简单地看成两部分: EventLoop 和 OS I/O封装.

#### **Libuv中的EventLoop**

我们先来看一个关于EventLoop的简单描述
> NodeJS运作在一个事件驱动的模式中, 这个模式主要包括两部分 **Event Demultiplexer(事件分配器)** 和 **Evbent Queue(事件队列)** . 所有的 **I/O请求** 最终都将产生一个完成或失败的事件或其他触发, 所有这些由I/O请求产生的我们都通称为 **Event(事件)** . NodeJS通过一定的算法来处理这些事件.

上述的描述中有四个概念需要梳理:

    1. Event
    2. I/O请求
    3. Event Demultiplexer(事件分配器)
    4. Evbent Queue(事件队列)

#### **I/O请求**

I/O请求的特点是耗时极长, CPU消耗极低, 因为CPU的执行非常快, 他的外围设备远远跟不上它的速度. 这里以一台电脑为例说明这个问题.

|范畴|元件|时钟周期|备注|
|:--|:--|:--|:--|
|北桥|CPU|1|一个简单指令, 3.0GHz, 1/3ns, 真空中的光走10厘米|
|北桥|L1 Cache|3|将时钟周期替换为秒单位, 相当于拿起一张稿纸(3s)|
|北桥|L2 Cache|14|相当于拿起并翻开一本书(14s)|
|北桥|主存|250|去楼下看一眼自己的车牌号(4min)|
|南桥|硬盘|41 million|辞职, 并开始环球旅行(1年3个月)|
|南桥|网络|240 million|辞职, 开始考研, 然后硕博连读(7年6个月)|

从这个对比中我们可以发现南桥所连接的设备, 硬盘和网卡的数据读写的过程非常缓慢, 所以量变产生质变, 这一类数据读写我们需要特殊地对待, 因此我们把这一类数据读写称为I/O请求.

#### **EventLoop的算法**

    1. 事件分配器接收到I/O请求后会将这些请求委派给相应的硬件.
    2. 一旦I/O请求被处理了(例如, 文件里的数据已经准备好被读取了, socket里的数据已经准备好被读取了 等等), 事件分配器就会将这个动作的已注册回调加进一个队列中以待处理. 这些回调就是我们说的事件, 而这个队列就是所谓的Event Queue(事件队列).
    3. 事件队列中的事件会被顺序执行, 直到事件队列清空.
    4. 如果事件队列里没有事件或者事件分配器里没有等待的请求时, 程序就会完成并退出. 否则就会继续步骤1.

#### ****











