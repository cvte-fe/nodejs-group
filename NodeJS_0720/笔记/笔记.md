# Node.js基本原理的简单介绍

----

## 本章提纲

1. Node.js的原理
    1. V8
    2. Libuv
        1. 事件循环
        2. I/O请求
        3. 事件分配器
        4. 事件队列
2. Node.js的特点
    1. 多线程编程模式
    2. 事件驱动与多线程的区别
    3. 单线程与动态编译
    4. C++模块入门

----

## 第一节 Node.js的原理

首先我们回答一个问题, Node.js是什么? 官网给出的回答是'JavaScript runtime built on Chrome's V8 JavaScript engine', 那么如何理解这个答案呢? 我认为Node.js最主要由两部分组成: V8和Libuv. 那么接下来我们看看这两部分分别做了哪些事情.

----

### V8做了什么

V8在执行代码的过程我们可以简单理解为4个步骤: 

|组件|产物|
|:--|:--|
|-|Source Code|
|Tokenizer|Token|
|Parser|Abstract syntax tree|
|Ignition解释器|Byte Code|
|TurboFan|Native code && run|

V8首先会将js源码解析成抽象语法树，通过ignition遍历语法树生成相应的字节码。这些字节码在执行过程中会被TurboFan编译成本地代码(机器码). 

另外我们经常听到的加速执行的技术JIT, 我们可以简单理解为在解释执行的过程中缓存热点的本地代码, 这里的关键是判断代码是否'热点'的算法.

17年之后V8抛弃了原先直接从AST到本地码的解释方式, 引入了字节码作为中间层, 主要考量是: 
    1.（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间
    2. 提高代码的启动速度
    3. 对 v8 的代码进行重构，降低 v8 的代码复杂度 (机器代码的多样性, 优化复杂)

这里我们只是对V8做一个简单的了解和梳理, 目的不是深入V8, 而只是知道他做了什么, 从而更方便地认识到另一部分(Libuv)做了什么.

----

### Libuv做了什么

接下来我们就来讨论Node.js的另一重要组成部分, Libuv的作用和简单的结构.

Libuv官网上的描述是'libuv是一个高性能/事件驱动I/O的跨平台API集'. 




