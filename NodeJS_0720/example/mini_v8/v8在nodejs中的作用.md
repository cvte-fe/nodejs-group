### 大背景  
- V8引擎是解决什么问题？随着web技术的快速发展，Javascript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行Javascript脚本。V8就是为了解决这一问题而生，在Node中也采用该引擎来解析Javascript. 
- 引擎

### V8是什么？  
V8 是 javascript 渲染引擎，随着chrome的发布（具体时间为2008年9月2号）。  


### V8之前Javascript的引擎做了什么？  
其他引擎：转换成字节码或解释执行；  
V8: 将js转为原生机器码（IA-32, x86-64, ARM, or MIPS CPUs）,并且使用了内联缓存（inline caching）等方法来提高性能。其可以独立运行，也可以嵌入到C++应用程序中运行。


### 一个完整JavaScript引擎的执行过程：

JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一边执行一边解析，而编译型语言在执行时已经完成编译。   
源代码 --> 抽象语法树 --> 字节码 --> JIT --> 本地代码；

- 抽象语法树   
![抽象语法树](https://ask.qcloudimg.com/http-save/yehe-1148531/rhiurti5js.png?imageView2/2/w/1620)

**为了节约将抽象语法树通过JIT技术转换成本地代码的时间**，V8放弃了生成字节码阶段的性能优化。而通过Profiler采集一些信息，来优化本地代码。  

在2017年4月底，v8 发布了5.9 版本，在此版本中新增了一个 Ignition 字节码解释器，并默认开启。做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度（详细请看：(JS 引擎与字节码的不解之缘)[https://cnodejs.org/topic/59084a9cbbaf2f3f569be482]）


- JIT(即时编译)；
    - 在运行的过程中检查热点代码，然后把代码编译成目标机器的机器码；从而省去了绝大部分的解释开销。
    - 优点：补全边运行边编译的性能问题；
    - 缺点：开发成本大，基本上每一个语言需要一个即时编译；
    - 代表：java系为代表的各种虚拟机，V8引擎；

### V8引擎
前面，我们介绍了V8引擎的一些历史，下面我们重点来看看V8项目一些知识。  
V8项目主要的结构如下：   
![V8结构](https://ask.qcloudimg.com/http-save/yehe-1148531/2oihcp6vtv.png?imageView2/2/w/1620)  

### 数据解析
js 做为一种无类型的语言，在编译时并不能准确知道变量的类型，只可以在运行时确定。而java、c++等静态类型语言，在编译时候就可以确切知道变量的类型。因而js的运行效率要低于c++或java。

### JavaScript代码编译过程
注意点：
- 在javascript源代码中，并非所有的函数都被编译成本地代码，从而采用在调用时才会编译的逻辑来动态编译。
- 由于v8缺少生成中间字节码这一环节，为了提升性能，V8会在生成本地代码后，使用数据分析器（profoler）采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。当发现优化后的代码性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。
- V8中，函数是一个基本单位，当某个JS函数被调用时，V8会查询该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这样那些不用的代码就可以减少执行时间。再次借助Runtime类中的辅助函数，将不用的空间进行标记清除和垃圾回收。（也就是在用的时候才会去编译，存储）；


### 优化回滚
- 由于V8是基于AST直接生成机器代码，没有经过中间层的优化，所以本地代码尚未经过很好的优化。
- 优化代码是一个很耗时的操作。
- 现阶段版本中，新增了一个Ignition字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译。消除了 Cranshaft 这个旧的编译器，并让新的Turbofan直接从字节码来优化代码，并当需要进行反优化的时候直接反优化到字节码，而不需要再考虑JS源代码。


### 垃圾回收


### 内存管理
- 年轻分代：主要是两个Zone之间的切换，一个是使用中空间（From空间），一个是闲置空间(To 空间)；并且该部分也有可能会升为年老分代；
- 年老分代：年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合；
- 大对象：


### 快照
- 快照机制：V8需要准备JS的运行环境，需要编译和执行JS先加载这些文件。并且每次开一个进程都需要准备这些，所有V8做了一些优化，将编译之后的代码通过序列化存在本地磁盘中，并且在下次实例化时直接将存储文件反序列化即可；
- 对于执行的js可以，V8还提供的拓展入口。可以让用户自定义快照，比如将TS编译器快照。


### V8 和 JavaScriptCore
- JavaScriptCore 苹果开源，稳健；
- V8 以性能优化为目标，较为激进；

- JavaScriptCore 的大致流程：源代码 --> 抽象语法树 --> 字节码 --> JIT --> 本地代码
- 最大的不同在于增加了字节码的中间表示，并且加入的多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码就行优化；


### 功能拓展
JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。

- 绑定：将拓展代码和JS引擎一起编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码，但是在实际的web开发中，开发者都是基于现有浏览器的，根本不可能介入JS引擎的编译中，绑定机制有很大的局限性，但是非常高效，并且适用于对性能要求较高的场景。（ 这一点可以应用与chromouse团队对书写笔迹的优化 ）


- 拓展：无需和V8编译，可以动态为引擎增加功能特性


### 总结
1. ***类型***。对于函数，JavaScript是一种动态类型语言，JavaScriptCore和V8都使用隐藏类和内嵌缓存来提高性能，为了保证缓存命中率，一个函数应该使用较少的数据类型；对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。这就是数据提取的实际作用；

2. ***数据表示***。简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，如果可以使用整数表示的，尽量不要用浮点类型。

3. 内存： 虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)

4. 优化回滚： 在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。













